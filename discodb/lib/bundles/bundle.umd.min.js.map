{"version":3,"file":"bundle.umd.min.js","sources":["../../discoFunctions/configMap.js","../../discoFunctions/discoGlobals.js","../../discoFunctions/idbOperations.js","../../discoFunctions/backgroundSync.js","../../discoFunctions/discoSync.js"],"sourcesContent":["const fs = require('fs');\nconst path = require('path');\n// import * as fs from 'fs';\n// import path from 'path';\n\n// import { dbGlobals } from './discodb.config.js'\n\nfunction find(targetPath) {\n  return findStartingWith(path.dirname(require.main.filename), targetPath);\n}\n\nfunction findStartingWith(start, target) {\n  const file = path.join(start, target);\n  try {\n    data = fs.readFileSync(file, 'utf-8');\n    return JSON.parse(data);\n  } catch (err) {\n    if (path.dirname(start) !== start) {\n      return findStartingWith(path.dirname(start), target);\n    }\n  }\n}\n\n// const dbGlobals = JSON.parse(userConfig);\n// console.log(dbGlobals)\n\nconst dbGlobals = find('discodb.config.json');\nconsole.log(dbGlobals)\n\n// module.exports = dbGlobals;\nexport default dbGlobals;","// import { dbGlobals } from '../../../discodb.config.js'\nimport dbGlobals from './configMap'\n\nconst idbPromise = {\n  DB: null\n}\n\nconst onlineUrlArr = [];\ndbGlobals.onlineRoutes.forEach(el => {\n  onlineUrlArr.push(el.url)\n});\n\nconst offlineUrlArr = [];\ndbGlobals.offlineRoutes.forEach(el => {\n  offlineUrlArr.push(el.url);\n});\n\nexport { dbGlobals, idbPromise, onlineUrlArr, offlineUrlArr }","import { idbPromise, dbGlobals } from './discoGlobals.js';\n\n/**\n * @property {Function} discoConnect Establishes connection to indexedDB & create Object Stores as specified in Configuration.\n * @param {Function} callback \n *\n */\nfunction discoConnect(callback) {\n  return new Promise((resolve, reject) => {\n    let req = indexedDB.open(dbGlobals.databaseName, dbGlobals.version)\n    req.onerror = (err) => {\n      //could not open db\n      console.log('Error: ', err);\n      idbPromise.DB = null;\n      reject(err);\n    };\n    req.onupgradeneeded = (event) => {\n      let db = event.target.result;\n      // Database Version Upgraded\n      if (!db.objectStoreNames.contains(dbGlobals.storeName)) {\n        db.createObjectStore(dbGlobals.storeName, {\n          keyPath: dbGlobals.keypath,\n        });\n      }\n      if (!db.objectStoreNames.contains(dbGlobals.syncQueue)) {\n        //Creating Object Store for Sync Queue\n        db.createObjectStore(dbGlobals.syncQueue, {\n          keyPath: 'id', autoIncrement: true,\n        })\n      }\n    };\n    req.onsuccess = (event) => {\n      idbPromise.DB = event.target.result;\n      //Database connected\n      if (callback) {\n        callback();\n      }\n      resolve(idbPromise.DB);\n      };\n  })\n};\n\n/**\n * @property {Function} discoAdd Adds an object in to the configured Object Store.\n * @param {Object} dataObject Object data to be stored.\n *\n */\nfunction discoAdd(dataObject) {\n   return new Promise ( (resolve, reject) => {\n    if (dataObject && idbPromise.DB) {\n      let tx = idbPromise.DB.transaction(dbGlobals.storeName, 'readwrite');\n\n      tx.onerror = (err) => {\n        console.log('Error:', err);\n        reject(err);\n      };\n      tx.oncomplete = (event) => {\n        //Data added successfully\n      };\n      \n      let store = tx.objectStore(dbGlobals.storeName);\n      let req = store.put(dataObject);\n\n      req.onsuccess = (event) => {\n        const result = event.target.result;\n        resolve(result);\n      };\n    } else {\n      console.log('DB is not connected');\n    }\n  })\n};\n\n/**\n * @property {Function} discoDeleteAll Deletes all properties of the configured Object Store.\n *\n */\nfunction discoDeleteAll() {\n  return new Promise( (resolve, reject) => {\n    if (idbPromise.DB) {\n      let tx = idbPromise.DB.transaction(dbGlobals.storeName, 'readwrite');\n      tx.onerror = (err) => {\n        console.log('Error:', err);\n        reject(err);\n      };\n      tx.oncomplete = (event) => {\n        // data deleted successfully \n      };\n      let store = tx.objectStore(dbGlobals.storeName);\n      const req = store.clear();\n      req.onsuccess = (event) => {\n        const result = event.target.result;\n        resolve(result);\n      };\n    } else {\n      console.log('DB is not connected');\n    }\n  })\n};\n\n/**\n * @property {Function} discoGetAll Gets all properties saved on the configured Object Store.\n * @return {Array} array of objects containing all properties in the Object Store.\n */\nfunction discoGetAll() {\n  return new Promise((resolve, reject) => {\n    if (idbPromise.DB) {\n      let tx = idbPromise.DB.transaction(dbGlobals.storeName, 'readonly');\n      tx.onerror = (err) => {\n        console.log('Error: ', err);\n        reject(err);\n      };\n      tx.oncomplete = (event) => {\n        //Transaction successful, all objects retrieved.\n      };\n      let store = tx.objectStore(dbGlobals.storeName);\n      const req = store.getAll();\n      req.onsuccess = (event) => {\n        const result = event.target.result;\n        resolve(result);\n      };\n    } else {\n      console.log('DB is not connected');\n    }\n  })\n}\n\n/**\n * @property {Function} discoDeleteOne Deletes one property on the configured Object Store.\n * @param {String} id The id of the object on the configured Object Store  * \n */\nfunction discoDeleteOne(id) {\n  return new Promise( (resolve, reject) => {\n    if (idbPromise.DB) {\n      let tx = idbPromise.DB.transaction(dbGlobals.storeName, 'readwrite');\n      tx.onerror = (err) => {\n        console.log('Error: ', err);\n        reject(err);\n      };\n      tx.oncomplete = (event) => {\n        //Transaction successful\n      };\n      let store = tx.objectStore(dbGlobals.storeName);\n      const req = store.delete(id);\n      req.onsuccess = (event) => {\n        const result = event.target.result;\n        resolve(result);\n      };\n    } else {\n      console.log('DB is not connected');\n    }\n  })\n}\n\n/**\n * @property {Function} discoUpdateOne Updates one property on the configured Object Store.\n * @param {Object} dataObject The req body object on the configured Object Store  \n * \n */\nfunction discoUpdateOne(dataObject) {\n  return new Promise ( (resolve, reject) => {\n    if (idbPromise.DB) {\n      let tx = idbPromise.DB.transaction(dbGlobals.storeName, 'readwrite');\n      tx.onerror = (err) => {\n        console.log('Error: ', err);\n        reject(err);\n      };\n      tx.oncomplete = (event) => {\n        //Transaction successful\n      };\n      let store = tx.objectStore(dbGlobals.storeName);\n      const req = store.put(dataObject);\n      req.onsuccess = (event) => {\n        const result = event.target.result;\n        resolve(result);\n      };\n    } else {\n      console.log('DB is not connected');\n    }\n  })\n};\n\nexport { discoConnect, discoAdd, discoDeleteAll, discoGetAll, discoDeleteOne, discoUpdateOne }; \n","import { idbPromise, dbGlobals } from './discoGlobals';\n\n/**\n * @property {Function} accessObjectStore Access object store in IDB database and start a transaction\n * @param {String} storeName Object store to be accessed for transaction  \n * @param {String} method  Method for transaction, \"readwrite, readonly\"\n * @return {Object} Accessed Object store Object \n */\nfunction accessObjectStore (storeName, method) {\n  return idbPromise.DB.transaction([storeName], method).objectStore(storeName)\n};\n/**\n * @property {Function} discoAddToQueue Adds Object into Object store\n * @param {Object} dataObject Objected to be added to Object store\n *  \n */\nfunction discoAddToQueue (dataObject) { \n  //Open a transaction to object store 'Queue' \n  const store = accessObjectStore(dbGlobals.syncQueue, 'readwrite')\n  //Add data to object store\n  store.add(dataObject)\n};\n/**\n * @property {Function} discoRegisterSync Request a \"Sync\" event to reattempt request when network is online.\n * \n */\nasync function discoRegisterSync() {\n  try {\n    const register = await registration.sync.register('discoSync');\n    return register;\n  } catch(error) {\n    console.log('Error:' , error);\n    return error;\n  }\n};\n\n/**\n * @property {Function} discoSyncToServer Accesses the Queue Object Store and re-sends all requests saved in application/json.\n * \n */\nfunction discoSyncToServer() {\n  const store = accessObjectStore(dbGlobals.syncQueue, 'readwrite');\n  const request = store.getAll();\n\n  request.onsuccess = function (event) {\n    const httpQueue = event.target.result;\n    //Comes back as an array of objects \n    //Iterate Queue store and initialize Fetch request\n    httpQueue.forEach((data) => {\n      const { url, method, body } = data\n      const headers = {'Content-Type': 'application/json'};\n      fetch(url, {\n        method: method,\n        headers: headers,\n        body: JSON.stringify(body)\n      })\n      .then((res) => res.json())\n      .then((res) => {\n        //Previous transaction was closed due to getAll()\n        //Reopen object store and delete the corresponding object on successful HTTP request\n        const newStore = accessObjectStore(dbGlobals.syncQueue, 'readwrite');\n        newStore.delete(data.id);\n      })\n      .catch((error) => {\n        console.error('Failed to sync data to server:', error);\n        throw error\n      })\n    });\n  }\n  request.onerror = (err) => {\n    console.log('Attempt to sync queue failed:', err);\n  }\n};\n\nexport { discoAddToQueue, discoRegisterSync, discoSyncToServer }; \n","import { discoConnect, discoGetAll, discoDeleteOne, discoUpdateOne, discoAdd, discoDeleteAll } from './idbOperations.js';\nimport { discoAddToQueue, discoRegisterSync } from './backgroundSync.js';\nimport { idbPromise , dbGlobals } from './discoGlobals.js';\n\n/**\n * @property {Function} discoSyncOffline Executes different IndexedDB logic based on the value of passed in method\n * @param {String} method This is the method property of the intercepted fetch request\n * @param {String} url This is the url property of the intercepted fetch request\n * @param {String} store This is the store property associated with the url provided in the config file\n * @param {Request} eventRequest This is the cloned version of the intercepted fetch request\n *\n */\nfunction discoSyncOffline(method, url, clonedRequest) {\n  switch(method) {\n    case 'GET':\n      if (idbPromise.DB) {\n        return discoGetAll().then((data) => {\n          const responseBody = { data };\n          const IDBData = new Response(JSON.stringify(responseBody));\n          return IDBData;\n        })\n      } else {\n        return discoConnect(() => {\n          discoGetAll().then((data) => {\n            const responseBody = {data: data};\n            const IDBData = new Response(JSON.stringify(responseBody));\n            return IDBData;\n          });\n        })\n      }\n    case 'DELETE':\n      return clonedRequest.json()\n      .then((data) => {\n        const reqBody = {\n          url: url,\n          method: method,\n          body: data\n        };\n        discoRegisterSync();\n        discoAddToQueue(reqBody);\n        const keypath = dbGlobals.keypath;\n        const id = data[keypath];\n        discoDeleteOne(id);\n        const deleteResponse = new Response(JSON.stringify({}));\n        return deleteResponse;\n      })\n      .catch( err => {\n        console.log('Error in DELETE block: ', err);\n      })\n    case 'PATCH':\n      return clonedRequest.json()\n      .then((data) => {\n        const reqBody = {\n          url: url,\n          method: method,\n          body: data\n        };\n        discoRegisterSync();\n        discoAddToQueue(reqBody);\n        const keypath = dbGlobals.keypath;\n        const id = data[keypath];\n        discoUpdateOne(data);\n        // returns empty object to trigger rerender in our app \n        const patchResponse = new Response(JSON.stringify({}));\n        return patchResponse;\n      }) \n    default:\n      return caches.match(clonedRequest)\n        .then(response => {\n          return response\n        })\n  }\n}\n\n/**\n * @property {Function} discoSyncOnline Establishes connection to indexedDB & create Object Stores as specified in Configuration.\n * @param {String} method This is the method property of the intercepted fetch request\n * @param {String} url This is the url property of the intercepted fetch request\n * @param {String} store This is the store property associated with the url provided in the config file\n * @param {Request} clonedResponse This is the cloned version of the intercepted fetch response\n *\n */\nfunction discoSyncOnline(method, url, clonedResponse) {\n  switch(method) {\n    case 'GET':\n      const resCloneDB = clonedResponse;\n      resCloneDB.json().then(data => {\n        if (idbPromise.DB) {\n          discoDeleteAll();\n        } else {\n          discoConnect( () => {\n            discoDeleteAll();\n          })\n        }\n        //populate indexedDB here\n        data.data.forEach( note => {\n          if (idbPromise.DB) {\n            discoAdd(note);\n          } else {\n            discoConnect(() => {\n              discoAdd(note);\n            })\n          }\n        })\n      });\n      break;\n    default:\n      break;\n  }\n}\n\nexport { discoSyncOffline, discoSyncOnline };"],"names":["fs","require","path","findStartingWith","start","target","file","join","data","readFileSync","JSON","parse","err","dirname","dbGlobals","targetPath","main","filename","console","log","idbPromise","DB","onlineUrlArr","onlineRoutes","forEach","el","push","url","offlineUrlArr","discoConnect","callback","Promise","resolve","reject","req","indexedDB","open","databaseName","version","onerror","onupgradeneeded","event","db","result","objectStoreNames","contains","storeName","createObjectStore","keyPath","keypath","syncQueue","autoIncrement","onsuccess","discoAdd","dataObject","tx","transaction","oncomplete","objectStore","put","discoDeleteAll","clear","discoGetAll","getAll","discoDeleteOne","id","delete","discoUpdateOne","accessObjectStore","method","discoAddToQueue","add","async","discoRegisterSync","registration","sync","register","error","offlineRoutes","clonedRequest","then","responseBody","Response","stringify","json","reqBody","body","catch","caches","match","response","clonedResponse","note","request","fetch","headers","res"],"mappings":"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"}