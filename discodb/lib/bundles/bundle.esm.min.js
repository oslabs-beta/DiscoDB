const e=require("fs"),t=require("path");function o(n,r){const s=t.join(n,r);try{return data=e.readFileSync(s,"utf-8"),JSON.parse(data)}catch(e){if(t.dirname(n)!==n)return o(t.dirname(n),r)}}const n=(r="discodb.config.json",o(t.dirname(require.main.filename),r));var r;console.log(n);const s={DB:null},c=[];n.onlineRoutes.forEach((e=>{c.push(e.url)}));const a=[];function i(e){return new Promise(((t,o)=>{let r=indexedDB.open(n.databaseName,n.version);r.onerror=e=>{console.log("Error: ",e),s.DB=null,o(e)},r.onupgradeneeded=e=>{let t=e.target.result;t.objectStoreNames.contains(n.storeName)||t.createObjectStore(n.storeName,{keyPath:n.keypath}),t.objectStoreNames.contains(n.syncQueue)||t.createObjectStore(n.syncQueue,{keyPath:"id",autoIncrement:!0})},r.onsuccess=o=>{s.DB=o.target.result,e&&e(),t(s.DB)}}))}function l(e){return new Promise(((t,o)=>{if(e&&s.DB){let r=s.DB.transaction(n.storeName,"readwrite");r.onerror=e=>{console.log("Error:",e),o(e)},r.oncomplete=e=>{},r.objectStore(n.storeName).put(e).onsuccess=e=>{const o=e.target.result;t(o)}}else console.log("DB is not connected")}))}function u(){return new Promise(((e,t)=>{if(s.DB){let o=s.DB.transaction(n.storeName,"readwrite");o.onerror=e=>{console.log("Error:",e),t(e)},o.oncomplete=e=>{};o.objectStore(n.storeName).clear().onsuccess=t=>{const o=t.target.result;e(o)}}else console.log("DB is not connected")}))}function d(){return new Promise(((e,t)=>{if(s.DB){let o=s.DB.transaction(n.storeName,"readonly");o.onerror=e=>{console.log("Error: ",e),t(e)},o.oncomplete=e=>{};o.objectStore(n.storeName).getAll().onsuccess=t=>{const o=t.target.result;e(o)}}else console.log("DB is not connected")}))}function f(e){return new Promise(((t,o)=>{if(s.DB){let r=s.DB.transaction(n.storeName,"readwrite");r.onerror=e=>{console.log("Error: ",e),o(e)},r.oncomplete=e=>{};r.objectStore(n.storeName).delete(e).onsuccess=e=>{const o=e.target.result;t(o)}}else console.log("DB is not connected")}))}function m(e){return new Promise(((t,o)=>{if(s.DB){let r=s.DB.transaction(n.storeName,"readwrite");r.onerror=e=>{console.log("Error: ",e),o(e)},r.oncomplete=e=>{};r.objectStore(n.storeName).put(e).onsuccess=e=>{const o=e.target.result;t(o)}}else console.log("DB is not connected")}))}function g(e,t){return s.DB.transaction([e],t).objectStore(e)}function h(e){g(n.syncQueue,"readwrite").add(e)}async function y(){try{return await registration.sync.register("discoSync")}catch(e){return console.log("Error:",e),e}}function D(){const e=g(n.syncQueue,"readwrite").getAll();e.onsuccess=function(e){e.target.result.forEach((e=>{const{url:t,method:o,body:r}=e;fetch(t,{method:o,headers:{"Content-Type":"application/json"},body:JSON.stringify(r)}).then((e=>e.json())).then((t=>{g(n.syncQueue,"readwrite").delete(e.id)})).catch((e=>{throw console.error("Failed to sync data to server:",e),e}))}))},e.onerror=e=>{console.log("Attempt to sync queue failed:",e)}}function p(e,t,o){switch(e){case"GET":return s.DB?d().then((e=>{const t={data:e};return new Response(JSON.stringify(t))})):i((()=>{d().then((e=>{const t={data:e};return new Response(JSON.stringify(t))}))}));case"DELETE":return o.json().then((o=>{const r={url:t,method:e,body:o};y(),h(r);f(o[n.keypath]);return new Response(JSON.stringify({}))})).catch((e=>{console.log("Error in DELETE block: ",e)}));case"PATCH":return o.json().then((o=>{const r={url:t,method:e,body:o};y(),h(r);o[n.keypath],m(o);return new Response(JSON.stringify({}))}));default:return caches.match(o).then((e=>e))}}function B(e,t,o){if("GET"===e){o.json().then((e=>{s.DB?u():i((()=>{u()})),e.data.forEach((e=>{s.DB?l(e):i((()=>{l(e)}))}))}))}}n.offlineRoutes.forEach((e=>{a.push(e.url)}));export{l as discoAdd,h as discoAddToQueue,i as discoConnect,u as discoDeleteAll,f as discoDeleteOne,d as discoGetAll,y as discoRegisterSync,p as discoSyncOffline,B as discoSyncOnline,D as discoSyncToServer,m as discoUpdateOne};
//# sourceMappingURL=bundle.esm.min.js.map
