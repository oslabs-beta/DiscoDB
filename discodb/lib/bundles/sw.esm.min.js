import e from"fs";import t from"path";const o=e,n=t;function r(e,t){const s=n.join(e,t);try{return data=o.readFileSync(s,"utf-8"),JSON.parse(data)}catch(o){if(n.dirname(e)!==e)return r(n.dirname(e),t)}}const s=(c="discodb.config.json",r(n.dirname(require.main.filename),c));var c;console.log(s);const a={DB:null},i=[];s.onlineRoutes.forEach((e=>{i.push(e.url)}));const l=[];function u(e){return new Promise(((t,o)=>{let n=indexedDB.open(s.databaseName,s.version);n.onerror=e=>{console.log("Error: ",e),a.DB=null,o(e)},n.onupgradeneeded=e=>{let t=e.target.result;t.objectStoreNames.contains(s.storeName)||t.createObjectStore(s.storeName,{keyPath:s.keypath}),t.objectStoreNames.contains(s.syncQueue)||t.createObjectStore(s.syncQueue,{keyPath:"id",autoIncrement:!0})},n.onsuccess=o=>{a.DB=o.target.result,e&&e(),t(a.DB)}}))}function d(e){return new Promise(((t,o)=>{if(e&&a.DB){let n=a.DB.transaction(s.storeName,"readwrite");n.onerror=e=>{console.log("Error:",e),o(e)},n.oncomplete=e=>{},n.objectStore(s.storeName).put(e).onsuccess=e=>{const o=e.target.result;t(o)}}else console.log("DB is not connected")}))}function h(){return new Promise(((e,t)=>{if(a.DB){let o=a.DB.transaction(s.storeName,"readwrite");o.onerror=e=>{console.log("Error:",e),t(e)},o.oncomplete=e=>{};o.objectStore(s.storeName).clear().onsuccess=t=>{const o=t.target.result;e(o)}}else console.log("DB is not connected")}))}function f(){return new Promise(((e,t)=>{if(a.DB){let o=a.DB.transaction(s.storeName,"readonly");o.onerror=e=>{console.log("Error: ",e),t(e)},o.oncomplete=e=>{};o.objectStore(s.storeName).getAll().onsuccess=t=>{const o=t.target.result;e(o)}}else console.log("DB is not connected")}))}function m(e,t){return a.DB.transaction([e],t).objectStore(e)}function g(e){m(s.syncQueue,"readwrite").add(e)}async function p(){try{return await registration.sync.register("discoSync")}catch(e){return console.log("Error:",e),e}}function y(e,t,o){switch(e){case"GET":return a.DB?f().then((e=>{const t={data:e};return new Response(JSON.stringify(t))})):u((()=>{f().then((e=>{const t={data:e};return new Response(JSON.stringify(t))}))}));case"DELETE":return o.json().then((o=>{const n={url:t,method:e,body:o};p(),g(n);!function(e){new Promise(((t,o)=>{if(a.DB){let n=a.DB.transaction(s.storeName,"readwrite");n.onerror=e=>{console.log("Error: ",e),o(e)},n.oncomplete=e=>{},n.objectStore(s.storeName).delete(e).onsuccess=e=>{const o=e.target.result;t(o)}}else console.log("DB is not connected")}))}(o[s.keypath]);return new Response(JSON.stringify({}))})).catch((e=>{console.log("Error in DELETE block: ",e)}));case"PATCH":return o.json().then((o=>{const n={url:t,method:e,body:o};p(),g(n);var r;o[s.keypath],r=o,new Promise(((e,t)=>{if(a.DB){let o=a.DB.transaction(s.storeName,"readwrite");o.onerror=e=>{console.log("Error: ",e),t(e)},o.oncomplete=e=>{},o.objectStore(s.storeName).put(r).onsuccess=t=>{const o=t.target.result;e(o)}}else console.log("DB is not connected")}));return new Response(JSON.stringify({}))}));default:return caches.match(o).then((e=>e))}}s.offlineRoutes.forEach((e=>{l.push(e.url)}));self.addEventListener("install",(e=>{console.log("Attempting to install service worker and cache static assets"),self.skipWaiting(),console.log("opening DB since sw is activated"),u()})),self.addEventListener("activate",(e=>{console.log("Activating new service worker...");const t=["my-site-cache-v3"];e.waitUntil(caches.keys().then((e=>Promise.all(e.map((e=>{if(-1===t.indexOf(e))return caches.delete(e)})))))),e.waitUntil(self.clients.claim())})),self.addEventListener("fetch",(e=>{const t=e.request.clone(),{url:o,method:n}=e.request;e.respondWith(fetch(e.request).then((t=>{const r=t.clone(),s=t.clone();return caches.open("my-site-cache-v3").then((t=>{t.put(e.request,r)})),i.includes(o)&&function(e,t,o){"GET"===e&&o.json().then((e=>{a.DB?h():u((()=>{h()})),e.data.forEach((e=>{a.DB?d(e):u((()=>{d(e)}))}))}))}(n,0,s),t})).catch((e=>l.includes(o)?y(n,o,t):caches.match(t).then((e=>e)))))})),self.addEventListener("sync",(e=>{"failed_requests"===e.tag&&e.waitUntil(function(){const e=m(s.syncQueue,"readwrite").getAll();e.onsuccess=function(e){e.target.result.forEach((e=>{const{url:t,method:o,body:n}=e;fetch(t,{method:o,headers:{"Content-Type":"application/json"},body:JSON.stringify(n)}).then((e=>e.json())).then((t=>{m(s.syncQueue,"readwrite").delete(e.id)})).catch((e=>{throw console.error("Failed to sync data to server:",e),e}))}))},e.onerror=e=>{console.log("Attempt to sync queue failed:",e)}}())}));
//# sourceMappingURL=sw.esm.min.js.map
