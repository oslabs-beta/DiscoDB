!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(require("fs"),require("path")):"function"==typeof define&&define.amd?define(["fs","path"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).require$$0,e.require$$1)}(this,(function(e,t){"use strict";function n(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}var o=n(e),r=n(t);const s=o.default,c=r.default;function a(e,t){const n=c.join(e,t);try{return data=s.readFileSync(n,"utf-8"),JSON.parse(data)}catch(n){if(c.dirname(e)!==e)return a(c.dirname(e),t)}}const i=(l="discodb.config.json",a(c.dirname(require.main.filename),l));var l;console.log(i);const u={DB:null},d=[];i.onlineRoutes.forEach((e=>{d.push(e.url)}));const f=[];function h(e){return new Promise(((t,n)=>{let o=indexedDB.open(i.databaseName,i.version);o.onerror=e=>{console.log("Error: ",e),u.DB=null,n(e)},o.onupgradeneeded=e=>{let t=e.target.result;t.objectStoreNames.contains(i.storeName)||t.createObjectStore(i.storeName,{keyPath:i.keypath}),t.objectStoreNames.contains(i.syncQueue)||t.createObjectStore(i.syncQueue,{keyPath:"id",autoIncrement:!0})},o.onsuccess=n=>{u.DB=n.target.result,e&&e(),t(u.DB)}}))}function m(e){return new Promise(((t,n)=>{if(e&&u.DB){let o=u.DB.transaction(i.storeName,"readwrite");o.onerror=e=>{console.log("Error:",e),n(e)},o.oncomplete=e=>{},o.objectStore(i.storeName).put(e).onsuccess=e=>{const n=e.target.result;t(n)}}else console.log("DB is not connected")}))}function g(){return new Promise(((e,t)=>{if(u.DB){let n=u.DB.transaction(i.storeName,"readwrite");n.onerror=e=>{console.log("Error:",e),t(e)},n.oncomplete=e=>{};n.objectStore(i.storeName).clear().onsuccess=t=>{const n=t.target.result;e(n)}}else console.log("DB is not connected")}))}function p(){return new Promise(((e,t)=>{if(u.DB){let n=u.DB.transaction(i.storeName,"readonly");n.onerror=e=>{console.log("Error: ",e),t(e)},n.oncomplete=e=>{};n.objectStore(i.storeName).getAll().onsuccess=t=>{const n=t.target.result;e(n)}}else console.log("DB is not connected")}))}function y(e,t){return u.DB.transaction([e],t).objectStore(e)}function w(e){y(i.syncQueue,"readwrite").add(e)}async function D(){try{return await registration.sync.register("discoSync")}catch(e){return console.log("Error:",e),e}}function B(e,t,n){switch(e){case"GET":return u.DB?p().then((e=>{const t={data:e};return new Response(JSON.stringify(t))})):h((()=>{p().then((e=>{const t={data:e};return new Response(JSON.stringify(t))}))}));case"DELETE":return n.json().then((n=>{const o={url:t,method:e,body:n};D(),w(o);!function(e){new Promise(((t,n)=>{if(u.DB){let o=u.DB.transaction(i.storeName,"readwrite");o.onerror=e=>{console.log("Error: ",e),n(e)},o.oncomplete=e=>{},o.objectStore(i.storeName).delete(e).onsuccess=e=>{const n=e.target.result;t(n)}}else console.log("DB is not connected")}))}(n[i.keypath]);return new Response(JSON.stringify({}))})).catch((e=>{console.log("Error in DELETE block: ",e)}));case"PATCH":return n.json().then((n=>{const o={url:t,method:e,body:n};D(),w(o);var r;n[i.keypath],r=n,new Promise(((e,t)=>{if(u.DB){let n=u.DB.transaction(i.storeName,"readwrite");n.onerror=e=>{console.log("Error: ",e),t(e)},n.oncomplete=e=>{},n.objectStore(i.storeName).put(r).onsuccess=t=>{const n=t.target.result;e(n)}}else console.log("DB is not connected")}));return new Response(JSON.stringify({}))}));default:return caches.match(n).then((e=>e))}}i.offlineRoutes.forEach((e=>{f.push(e.url)}));const E="my-site-cache-v3";self.addEventListener("install",(e=>{console.log("Attempting to install service worker and cache static assets"),self.skipWaiting(),console.log("opening DB since sw is activated"),h()})),self.addEventListener("activate",(e=>{console.log("Activating new service worker...");const t=[E];e.waitUntil(caches.keys().then((e=>Promise.all(e.map((e=>{if(-1===t.indexOf(e))return caches.delete(e)})))))),e.waitUntil(self.clients.claim())})),self.addEventListener("fetch",(e=>{const t=e.request.clone(),{url:n,method:o}=e.request;e.respondWith(fetch(e.request).then((t=>{const r=t.clone(),s=t.clone();return caches.open(E).then((t=>{t.put(e.request,r)})),d.includes(n)&&function(e,t,n){"GET"===e&&n.json().then((e=>{u.DB?g():h((()=>{g()})),e.data.forEach((e=>{u.DB?m(e):h((()=>{m(e)}))}))}))}(o,0,s),t})).catch((e=>f.includes(n)?B(o,n,t):caches.match(t).then((e=>e)))))})),self.addEventListener("sync",(e=>{"failed_requests"===e.tag&&e.waitUntil(function(){const e=y(i.syncQueue,"readwrite").getAll();e.onsuccess=function(e){e.target.result.forEach((e=>{const{url:t,method:n,body:o}=e;fetch(t,{method:n,headers:{"Content-Type":"application/json"},body:JSON.stringify(o)}).then((e=>e.json())).then((t=>{y(i.syncQueue,"readwrite").delete(e.id)})).catch((e=>{throw console.error("Failed to sync data to server:",e),e}))}))},e.onerror=e=>{console.log("Attempt to sync queue failed:",e)}}())}))}));
//# sourceMappingURL=sw.umd.min.js.map
