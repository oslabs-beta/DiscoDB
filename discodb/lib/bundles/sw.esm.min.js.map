{"version":3,"file":"sw.esm.min.js","sources":["../../discoFunctions/configMap.js","../../discoFunctions/discoGlobals.js","../../discoFunctions/idbOperations.js","../../discoFunctions/backgroundSync.js","../../discoFunctions/discoSync.js","../../discoFunctions/swCacheSite-indexedDB.js"],"sourcesContent":["const fs = require('fs');\nconst path = require('path');\n// import * as fs from 'fs';\n// import path from 'path';\n\n// import { dbGlobals } from './discodb.config.js'\n\nfunction find(targetPath) {\n  return findStartingWith(path.dirname(require.main.filename), targetPath);\n}\n\nfunction findStartingWith(start, target) {\n  const file = path.join(start, target);\n  try {\n    data = fs.readFileSync(file, 'utf-8');\n    return JSON.parse(data);\n  } catch (err) {\n    if (path.dirname(start) !== start) {\n      return findStartingWith(path.dirname(start), target);\n    }\n  }\n}\n\n// const dbGlobals = JSON.parse(userConfig);\n// console.log(dbGlobals)\n\nconst dbGlobals = find('discodb.config.json');\nconsole.log(dbGlobals)\n\n// module.exports = dbGlobals;\nexport default dbGlobals;","// import { dbGlobals } from '../../../discodb.config.js'\nimport dbGlobals from './configMap'\n\nconst idbPromise = {\n  DB: null\n}\n\nconst onlineUrlArr = [];\ndbGlobals.onlineRoutes.forEach(el => {\n  onlineUrlArr.push(el.url)\n});\n\nconst offlineUrlArr = [];\ndbGlobals.offlineRoutes.forEach(el => {\n  offlineUrlArr.push(el.url);\n});\n\nexport { dbGlobals, idbPromise, onlineUrlArr, offlineUrlArr }","import { idbPromise, dbGlobals } from './discoGlobals.js';\n\n/**\n * @property {Function} discoConnect Establishes connection to indexedDB & create Object Stores as specified in Configuration.\n * @param {Function} callback \n *\n */\nfunction discoConnect(callback) {\n  return new Promise((resolve, reject) => {\n    let req = indexedDB.open(dbGlobals.databaseName, dbGlobals.version)\n    req.onerror = (err) => {\n      //could not open db\n      console.log('Error: ', err);\n      idbPromise.DB = null;\n      reject(err);\n    };\n    req.onupgradeneeded = (event) => {\n      let db = event.target.result;\n      // Database Version Upgraded\n      if (!db.objectStoreNames.contains(dbGlobals.storeName)) {\n        db.createObjectStore(dbGlobals.storeName, {\n          keyPath: dbGlobals.keypath,\n        });\n      }\n      if (!db.objectStoreNames.contains(dbGlobals.syncQueue)) {\n        //Creating Object Store for Sync Queue\n        db.createObjectStore(dbGlobals.syncQueue, {\n          keyPath: 'id', autoIncrement: true,\n        })\n      }\n    };\n    req.onsuccess = (event) => {\n      idbPromise.DB = event.target.result;\n      //Database connected\n      if (callback) {\n        callback();\n      }\n      resolve(idbPromise.DB);\n      };\n  })\n};\n\n/**\n * @property {Function} discoAdd Adds an object in to the configured Object Store.\n * @param {Object} dataObject Object data to be stored.\n *\n */\nfunction discoAdd(dataObject) {\n   return new Promise ( (resolve, reject) => {\n    if (dataObject && idbPromise.DB) {\n      let tx = idbPromise.DB.transaction(dbGlobals.storeName, 'readwrite');\n\n      tx.onerror = (err) => {\n        console.log('Error:', err);\n        reject(err);\n      };\n      tx.oncomplete = (event) => {\n        //Data added successfully\n      };\n      \n      let store = tx.objectStore(dbGlobals.storeName);\n      let req = store.put(dataObject);\n\n      req.onsuccess = (event) => {\n        const result = event.target.result;\n        resolve(result);\n      };\n    } else {\n      console.log('DB is not connected');\n    }\n  })\n};\n\n/**\n * @property {Function} discoDeleteAll Deletes all properties of the configured Object Store.\n *\n */\nfunction discoDeleteAll() {\n  return new Promise( (resolve, reject) => {\n    if (idbPromise.DB) {\n      let tx = idbPromise.DB.transaction(dbGlobals.storeName, 'readwrite');\n      tx.onerror = (err) => {\n        console.log('Error:', err);\n        reject(err);\n      };\n      tx.oncomplete = (event) => {\n        // data deleted successfully \n      };\n      let store = tx.objectStore(dbGlobals.storeName);\n      const req = store.clear();\n      req.onsuccess = (event) => {\n        const result = event.target.result;\n        resolve(result);\n      };\n    } else {\n      console.log('DB is not connected');\n    }\n  })\n};\n\n/**\n * @property {Function} discoGetAll Gets all properties saved on the configured Object Store.\n * @return {Array} array of objects containing all properties in the Object Store.\n */\nfunction discoGetAll() {\n  return new Promise((resolve, reject) => {\n    if (idbPromise.DB) {\n      let tx = idbPromise.DB.transaction(dbGlobals.storeName, 'readonly');\n      tx.onerror = (err) => {\n        console.log('Error: ', err);\n        reject(err);\n      };\n      tx.oncomplete = (event) => {\n        //Transaction successful, all objects retrieved.\n      };\n      let store = tx.objectStore(dbGlobals.storeName);\n      const req = store.getAll();\n      req.onsuccess = (event) => {\n        const result = event.target.result;\n        resolve(result);\n      };\n    } else {\n      console.log('DB is not connected');\n    }\n  })\n}\n\n/**\n * @property {Function} discoDeleteOne Deletes one property on the configured Object Store.\n * @param {String} id The id of the object on the configured Object Store  * \n */\nfunction discoDeleteOne(id) {\n  return new Promise( (resolve, reject) => {\n    if (idbPromise.DB) {\n      let tx = idbPromise.DB.transaction(dbGlobals.storeName, 'readwrite');\n      tx.onerror = (err) => {\n        console.log('Error: ', err);\n        reject(err);\n      };\n      tx.oncomplete = (event) => {\n        //Transaction successful\n      };\n      let store = tx.objectStore(dbGlobals.storeName);\n      const req = store.delete(id);\n      req.onsuccess = (event) => {\n        const result = event.target.result;\n        resolve(result);\n      };\n    } else {\n      console.log('DB is not connected');\n    }\n  })\n}\n\n/**\n * @property {Function} discoUpdateOne Updates one property on the configured Object Store.\n * @param {Object} dataObject The req body object on the configured Object Store  \n * \n */\nfunction discoUpdateOne(dataObject) {\n  return new Promise ( (resolve, reject) => {\n    if (idbPromise.DB) {\n      let tx = idbPromise.DB.transaction(dbGlobals.storeName, 'readwrite');\n      tx.onerror = (err) => {\n        console.log('Error: ', err);\n        reject(err);\n      };\n      tx.oncomplete = (event) => {\n        //Transaction successful\n      };\n      let store = tx.objectStore(dbGlobals.storeName);\n      const req = store.put(dataObject);\n      req.onsuccess = (event) => {\n        const result = event.target.result;\n        resolve(result);\n      };\n    } else {\n      console.log('DB is not connected');\n    }\n  })\n};\n\nexport { discoConnect, discoAdd, discoDeleteAll, discoGetAll, discoDeleteOne, discoUpdateOne }; \n","import { idbPromise, dbGlobals } from './discoGlobals';\n\n/**\n * @property {Function} accessObjectStore Access object store in IDB database and start a transaction\n * @param {String} storeName Object store to be accessed for transaction  \n * @param {String} method  Method for transaction, \"readwrite, readonly\"\n * @return {Object} Accessed Object store Object \n */\nfunction accessObjectStore (storeName, method) {\n  return idbPromise.DB.transaction([storeName], method).objectStore(storeName)\n};\n/**\n * @property {Function} discoAddToQueue Adds Object into Object store\n * @param {Object} dataObject Objected to be added to Object store\n *  \n */\nfunction discoAddToQueue (dataObject) { \n  //Open a transaction to object store 'Queue' \n  const store = accessObjectStore(dbGlobals.syncQueue, 'readwrite')\n  //Add data to object store\n  store.add(dataObject)\n};\n/**\n * @property {Function} discoRegisterSync Request a \"Sync\" event to reattempt request when network is online.\n * \n */\nasync function discoRegisterSync() {\n  try {\n    const register = await registration.sync.register('discoSync');\n    return register;\n  } catch(error) {\n    console.log('Error:' , error);\n    return error;\n  }\n};\n\n/**\n * @property {Function} discoSyncToServer Accesses the Queue Object Store and re-sends all requests saved in application/json.\n * \n */\nfunction discoSyncToServer() {\n  const store = accessObjectStore(dbGlobals.syncQueue, 'readwrite');\n  const request = store.getAll();\n\n  request.onsuccess = function (event) {\n    const httpQueue = event.target.result;\n    //Comes back as an array of objects \n    //Iterate Queue store and initialize Fetch request\n    httpQueue.forEach((data) => {\n      const { url, method, body } = data\n      const headers = {'Content-Type': 'application/json'};\n      fetch(url, {\n        method: method,\n        headers: headers,\n        body: JSON.stringify(body)\n      })\n      .then((res) => res.json())\n      .then((res) => {\n        //Previous transaction was closed due to getAll()\n        //Reopen object store and delete the corresponding object on successful HTTP request\n        const newStore = accessObjectStore(dbGlobals.syncQueue, 'readwrite');\n        newStore.delete(data.id);\n      })\n      .catch((error) => {\n        console.error('Failed to sync data to server:', error);\n        throw error\n      })\n    });\n  }\n  request.onerror = (err) => {\n    console.log('Attempt to sync queue failed:', err);\n  }\n};\n\nexport { discoAddToQueue, discoRegisterSync, discoSyncToServer }; \n","import { discoConnect, discoGetAll, discoDeleteOne, discoUpdateOne, discoAdd, discoDeleteAll } from './idbOperations.js';\nimport { discoAddToQueue, discoRegisterSync } from './backgroundSync.js';\nimport { idbPromise , dbGlobals } from './discoGlobals.js';\n\n/**\n * @property {Function} discoSyncOffline Executes different IndexedDB logic based on the value of passed in method\n * @param {String} method This is the method property of the intercepted fetch request\n * @param {String} url This is the url property of the intercepted fetch request\n * @param {String} store This is the store property associated with the url provided in the config file\n * @param {Request} eventRequest This is the cloned version of the intercepted fetch request\n *\n */\nfunction discoSyncOffline(method, url, clonedRequest) {\n  switch(method) {\n    case 'GET':\n      if (idbPromise.DB) {\n        return discoGetAll().then((data) => {\n          const responseBody = { data };\n          const IDBData = new Response(JSON.stringify(responseBody));\n          return IDBData;\n        })\n      } else {\n        return discoConnect(() => {\n          discoGetAll().then((data) => {\n            const responseBody = {data: data};\n            const IDBData = new Response(JSON.stringify(responseBody));\n            return IDBData;\n          });\n        })\n      }\n    case 'DELETE':\n      return clonedRequest.json()\n      .then((data) => {\n        const reqBody = {\n          url: url,\n          method: method,\n          body: data\n        };\n        discoRegisterSync();\n        discoAddToQueue(reqBody);\n        const keypath = dbGlobals.keypath;\n        const id = data[keypath];\n        discoDeleteOne(id);\n        const deleteResponse = new Response(JSON.stringify({}));\n        return deleteResponse;\n      })\n      .catch( err => {\n        console.log('Error in DELETE block: ', err);\n      })\n    case 'PATCH':\n      return clonedRequest.json()\n      .then((data) => {\n        const reqBody = {\n          url: url,\n          method: method,\n          body: data\n        };\n        discoRegisterSync();\n        discoAddToQueue(reqBody);\n        const keypath = dbGlobals.keypath;\n        const id = data[keypath];\n        discoUpdateOne(data);\n        // returns empty object to trigger rerender in our app \n        const patchResponse = new Response(JSON.stringify({}));\n        return patchResponse;\n      }) \n    default:\n      return caches.match(clonedRequest)\n        .then(response => {\n          return response\n        })\n  }\n}\n\n/**\n * @property {Function} discoSyncOnline Establishes connection to indexedDB & create Object Stores as specified in Configuration.\n * @param {String} method This is the method property of the intercepted fetch request\n * @param {String} url This is the url property of the intercepted fetch request\n * @param {String} store This is the store property associated with the url provided in the config file\n * @param {Request} clonedResponse This is the cloned version of the intercepted fetch response\n *\n */\nfunction discoSyncOnline(method, url, clonedResponse) {\n  switch(method) {\n    case 'GET':\n      const resCloneDB = clonedResponse;\n      resCloneDB.json().then(data => {\n        if (idbPromise.DB) {\n          discoDeleteAll();\n        } else {\n          discoConnect( () => {\n            discoDeleteAll();\n          })\n        }\n        //populate indexedDB here\n        data.data.forEach( note => {\n          if (idbPromise.DB) {\n            discoAdd(note);\n          } else {\n            discoConnect(() => {\n              discoAdd(note);\n            })\n          }\n        })\n      });\n      break;\n    default:\n      break;\n  }\n}\n\nexport { discoSyncOffline, discoSyncOnline };","import { discoConnect } from './idbOperations.js';\nimport { discoSyncToServer } from './backgroundSync.js';\nimport { discoSyncOffline, discoSyncOnline } from './discoSync.js';\nimport { onlineUrlArr, offlineUrlArr, dbGlobals, idbPromise } from './discoGlobals.js';\n\n\nconst cacheName = 'my-site-cache-v3';\n\nself.addEventListener('install', event => {\n  console.log('Attempting to install service worker and cache static assets');\n  self.skipWaiting();\n  console.log('opening DB since sw is activated')\n  discoConnect();\n});\n\nself.addEventListener('activate', event => {\n  console.log('Activating new service worker...');\n  const cacheAllowlist = [cacheName];\n  //Remove unwanted caches\n  event.waitUntil(\n    caches.keys().then(cacheNames => {\n      return Promise.all(\n        cacheNames.map(cacheName => {\n          if (cacheAllowlist.indexOf(cacheName) === -1) {\n            return caches.delete(cacheName);\n          }\n        })\n      )\n    })\n  );\n  //Force SW to become available to all pages\n  event.waitUntil(self.clients.claim());\n});\n\nself.addEventListener('fetch', event => {\n  //clone the request so that the body of the request will still be available\n  const reqClone = event.request.clone();\n  const { url, method } = event.request;\n  event.respondWith(\n    fetch(event.request)\n    .then( (response) => {\n      // Make clone of response\n      const resCloneCache = response.clone();\n      const resCloneDB = response.clone()\n      //Open cache\n      caches\n        .open(cacheName)\n        .then(cache => {\n          //Add response to cache\n          cache.put(event.request, resCloneCache);\n        })      \n      //invoke online reducer to populate indexedDB\n      if (onlineUrlArr.includes(url)){\n        discoSyncOnline(method, url, resCloneDB);  \n      }\n      return response;\n    })\n    // if network is unavailable\n    .catch((err) => {\n      //invoke offline reducer to perform RUD functions to indexedDB\n      if (offlineUrlArr.includes(url)){\n        return discoSyncOffline(method, url, reqClone); \n      }\n      return caches.match(reqClone)\n      .then(response => {\n        return response\n      })\n    })\n  )\n});\n\n//When back online, listener will be invoked.\n//WaitUntil: waits for service workers until promise resolves\n  //Then invoke syncData\nself.addEventListener('sync', (event) => {\n  if(event.tag === 'failed_requests'){\n    event.waitUntil(discoSyncToServer())\n  };\n});\n"],"names":["fs","require$$0","path","require$$1","findStartingWith","start","target","file","join","data","readFileSync","JSON","parse","err","dirname","dbGlobals","targetPath","require","main","filename","console","log","idbPromise","DB","onlineUrlArr","onlineRoutes","forEach","el","push","url","offlineUrlArr","discoConnect","callback","Promise","resolve","reject","req","indexedDB","open","databaseName","version","onerror","onupgradeneeded","event","db","result","objectStoreNames","contains","storeName","createObjectStore","keyPath","keypath","syncQueue","autoIncrement","onsuccess","discoAdd","dataObject","tx","transaction","oncomplete","objectStore","put","discoDeleteAll","clear","discoGetAll","getAll","accessObjectStore","method","discoAddToQueue","add","async","discoRegisterSync","registration","sync","register","error","discoSyncOffline","clonedRequest","then","responseBody","Response","stringify","json","reqBody","body","id","delete","discoDeleteOne","catch","caches","match","response","offlineRoutes","self","addEventListener","skipWaiting","cacheAllowlist","waitUntil","keys","cacheNames","all","map","cacheName","indexOf","clients","claim","reqClone","request","clone","respondWith","fetch","resCloneCache","resCloneDB","cache","includes","clonedResponse","note","discoSyncOnline","tag","headers","res","discoSyncToServer"],"mappings":"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"}